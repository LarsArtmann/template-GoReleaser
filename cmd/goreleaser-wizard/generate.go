package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/charmbracelet/log"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var generateCmd = &cobra.Command{
	Use:   "generate",
	Short: "Generate GoReleaser configuration with flags (non-interactive)",
	Long: `Generate GoReleaser configuration using command-line flags instead of
the interactive wizard. Useful for CI/CD pipelines and automation.`,
	Run: runGenerate,
}

func init() {
	generateCmd.Flags().String("name", "", "project name")
	generateCmd.Flags().String("description", "", "project description")
	generateCmd.Flags().String("binary", "", "binary name")
	generateCmd.Flags().String("main", ".", "path to main.go")
	generateCmd.Flags().StringSlice("platforms", []string{"linux", "darwin", "windows"}, "target platforms")
	generateCmd.Flags().StringSlice("architectures", []string{"amd64", "arm64"}, "target architectures")
	generateCmd.Flags().Bool("docker", false, "enable Docker builds")
	generateCmd.Flags().Bool("signing", false, "enable code signing")
	generateCmd.Flags().Bool("github-action", false, "generate GitHub Actions workflow")
	generateCmd.Flags().Bool("force", false, "overwrite existing files")
}

func runGenerate(cmd *cobra.Command, args []string) {
	// Set up logger
	logger := log.New(os.Stderr)
	if viper.GetBool("debug") {
		logger.SetLevel(log.DebugLevel)
	}

	// Set up panic recovery
	defer HandlePanic("generate command", logger)

	config := &ProjectConfig{}

	// Parse flags
	config.ProjectName, _ = cmd.Flags().GetString("name")
	config.ProjectDescription, _ = cmd.Flags().GetString("description")
	config.BinaryName, _ = cmd.Flags().GetString("binary")
	config.MainPath, _ = cmd.Flags().GetString("main")
	config.Platforms, _ = cmd.Flags().GetStringSlice("platforms")
	config.Architectures, _ = cmd.Flags().GetStringSlice("architectures")
	config.DockerEnabled, _ = cmd.Flags().GetBool("docker")
	config.Signing, _ = cmd.Flags().GetBool("signing")
	config.GenerateActions, _ = cmd.Flags().GetBool("github-action")

	force, _ := cmd.Flags().GetBool("force")

	// Validate required fields
	if config.ProjectName == "" {
		detectProjectInfo(config)
		if config.ProjectName == "" {
			err := UserInputError(
				"project name",
				ErrUserInput,
			)
			err.Suggestions = append(err.Suggestions, "Use --name flag to specify project name")
			LogAndDisplayError(err, logger)
			return
		}
	}

	if config.BinaryName == "" {
		config.BinaryName = config.ProjectName
	}

	// Check existing files
	if !force {
		if err := CheckFileExists(".goreleaser.yaml", false); err == nil {
			err := NewWizardError(
				"file exists check",
				ErrFileOperation,
				".goreleaser.yaml already exists",
				true,
				"Use --force flag to overwrite existing file",
				"Backup existing config before overwriting",
				"Choose a different output location",
			)
			LogAndDisplayError(err, logger)
			return
		}
	}

	// Generate files
	fmt.Println(titleStyle.Render("Generating GoReleaser configuration..."))

	if err := generateGoReleaserConfig(config); err != nil {
		LogAndDisplayError(TemplateError("goreleaser.yaml", err), logger)
		return
	}
	fmt.Println(successStyle.Render("✓ Created .goreleaser.yaml"))

	if config.GenerateActions {
		if err := generateGitHubActions(config); err != nil {
			LogAndDisplayError(TemplateError("github actions workflow", err), logger)
			return
		}
		fmt.Println(successStyle.Render("✓ Created .github/workflows/release.yml"))
	}

	fmt.Println(successStyle.Render("\n✨ Configuration generated successfully!"))
}

func generateGoReleaserConfig(config *ProjectConfig) error {
	// Validate config before generating
	if config.ProjectName == "" {
		return UserInputError("project name", fmt.Errorf("project name cannot be empty"))
	}
	if config.BinaryName == "" {
		return UserInputError("binary name", fmt.Errorf("binary name cannot be empty"))
	}

	tmpl := `# GoReleaser configuration
# Generated by goreleaser-wizard
# https://goreleaser.com

version: 2

project_name: {{.ProjectName}}

before:
  hooks:
    - go mod tidy
    - go generate ./...{{if not .SkipValidation}}
    - go test ./...{{end}}

builds:
  - id: {{.BinaryName}}
    main: {{.MainPath}}
    binary: {{.BinaryName}}
    
    env:
      - CGO_ENABLED={{if .CGOEnabled}}1{{else}}0{{end}}
    
    goos:{{range .Platforms}}
      - {{.}}{{end}}
    
    goarch:{{range .Architectures}}
      - {{.}}{{end}}
    {{if .LDFlags}}
    ldflags:
      - -s -w
      - -X main.version={{"{{"}}{{"}}"}}Version{{"{{"}}{{"}}"}}
      - -X main.commit={{"{{"}}{{"}}"}}Commit{{"{{"}}{{"}}"}}
      - -X main.date={{"{{"}}{{"}}"}}Date{{"{{"}}{{"}}"}}
      - -X main.builtBy=goreleaser{{end}}
    
    # Ignore certain platform combinations
    ignore:
      - goos: darwin
        goarch: 386
      - goos: windows
        goarch: arm64{{if not .CGOEnabled}}
    
    # Build tags for pure Go builds
    tags:
      - netgo
      - osusergo{{end}}

archives:
  - id: default
    name_template: >-
      {{"{{"}} .ProjectName {{"}}"}}_
      {{"{{"}} .Version {{"}}"}}_
      {{"{{"}} title .Os {{"}}"}}_
      {{"{{"}} if eq .Arch "amd64" {{"}}"}}x86_64
      {{"{{"}} else if eq .Arch "386" {{"}}"}}i386
      {{"{{"}} else {{"}}"}}{{"{{"}} .Arch {{"}}"}}{{"{{"}} end {{"}}"}}
    
    format_overrides:
      - goos: windows
        format: zip
    
    files:
      - LICENSE*
      - README*
      - CHANGELOG*

checksum:
  name_template: 'checksums.txt'
  algorithm: sha256

snapshot:
  version_template: "{{"{{"}} incpatch .Version {{"}}"}}-next"

changelog:
  sort: asc
  use: github
  filters:
    exclude:
      - '^docs:'
      - '^test:'
      - '^chore:'
      - Merge pull request
      - Merge branch

release:{{if eq .GitProvider "GitHub"}}
  github:
    owner: {{"{{"}} .Env.GITHUB_OWNER {{"}}"}}
    name: {{"{{"}} .Env.GITHUB_REPO {{"}}"}}{{else if eq .GitProvider "GitLab"}}
  gitlab:
    owner: {{"{{"}} .Env.GITLAB_OWNER {{"}}"}}
    name: {{"{{"}} .Env.GITLAB_REPO {{"}}"}}{{else if eq .GitProvider "Gitea"}}
  gitea:
    owner: {{"{{"}} .Env.GITEA_OWNER {{"}}"}}
    name: {{"{{"}} .Env.GITEA_REPO {{"}}"}}{{end}}
  
  draft: false
  prerelease: auto
  mode: append
  
  footer: |
    ## Installation
    Download the appropriate archive for your platform from the assets below.
    
    ### Quick Install
    ` + "```bash" + `
    # macOS/Linux
    curl -sfL https://github.com/{{"{{"}} .Env.GITHUB_OWNER {{"}}"}}/{{"{{"}} .Env.GITHUB_REPO {{"}}"}}/releases/download/{{"{{"}} .Tag {{"}}"}}/{{"{{"}} .ProjectName {{"}}"}}_{{"{{"}} .Version {{"}}"}}_{{"{{"}} title .Os {{"}}"}}_{{"{{"}} .Arch {{"}}"}}.tar.gz | tar -xz
    
    # Windows (PowerShell)
    Invoke-WebRequest -Uri "https://github.com/{{"{{"}} .Env.GITHUB_OWNER {{"}}"}}/{{"{{"}} .Env.GITHUB_REPO {{"}}"}}/releases/download/{{"{{"}} .Tag {{"}}"}}/{{"{{"}} .ProjectName {{"}}"}}_{{"{{"}} .Version {{"}}"}}_Windows_x86_64.zip" -OutFile "{{.BinaryName}}.zip"
    ` + "```" + `
{{if .DockerEnabled}}
dockers:
  - image_templates:
      - "{{.DockerRegistry}}/{{.ProjectName}}:{{"{{"}} .Tag {{"}}"}}"
      - "{{.DockerRegistry}}/{{.ProjectName}}:latest"
    
    dockerfile: Dockerfile
    
    build_flag_templates:
      - "--pull"
      - "--label=org.opencontainers.image.created={{"{{"}} .Date {{"}}"}}"
      - "--label=org.opencontainers.image.title={{"{{"}} .ProjectName {{"}}"}}"
      - "--label=org.opencontainers.image.revision={{"{{"}} .FullCommit {{"}}"}}"
      - "--label=org.opencontainers.image.version={{"{{"}} .Version {{"}}"}}"
{{end}}{{if .Signing}}
signs:
  - cmd: cosign
    certificate: '${artifact}.pem'
    args:
      - sign-blob
      - '--oidc-issuer=https://token.actions.githubusercontent.com'
      - '--output-certificate=${certificate}'
      - '--output-signature=${signature}'
      - '${artifact}'
    artifacts: all
    output: true
{{end}}{{if .SBOM}}
sboms:
  - artifacts: archive
{{end}}{{if .Homebrew}}
brews:
  - repository:
      owner: {{"{{"}} .Env.GITHUB_OWNER {{"}}"}}
      name: homebrew-tap
    
    folder: Formula
    
    description: "{{.ProjectDescription}}"
    homepage: "https://github.com/{{"{{"}} .Env.GITHUB_OWNER {{"}}"}}/{{.ProjectName}}"
    license: "MIT"
    
    test: |
      system "#{bin}/{{.BinaryName}} version"
{{end}}{{if .Snap}}
snaps:
  - name: {{.ProjectName}}
    summary: "{{.ProjectDescription}}"
    description: |
      {{.ProjectDescription}}
      
      This snap is automatically built and published by GoReleaser.
    
    grade: stable
    confinement: strict
    
    apps:
      {{.BinaryName}}:
        command: {{.BinaryName}}
{{end}}`

	t, err := template.New("goreleaser").Parse(tmpl)
	if err != nil {
		return TemplateError("goreleaser template parsing", err)
	}

	file, err := SafeCreateFile(".goreleaser.yaml")
	if err != nil {
		return err // Already wrapped by SafeCreateFile
	}
	defer func() {
		if closeErr := file.Close(); closeErr != nil {
			// Log close error but don't override main error
			log.Warn("Failed to close file", "file", ".goreleaser.yaml", "error", closeErr)
		}
	}()

	// Set defaults
	if config.LDFlags {
		config.LDFlags = true
	}
	if config.GitProvider == "" {
		config.GitProvider = "GitHub"
	}

	if err := t.Execute(file, config); err != nil {
		return TemplateError("goreleaser template execution", err)
	}
	return nil
}

func generateGitHubActions(config *ProjectConfig) error {
	// Create directory if it doesn't exist with proper error handling
	workflowDir := ".github/workflows"
	if err := os.MkdirAll(workflowDir, 0755); err != nil {
		return WrapFileError("create workflows directory", workflowDir, err)
	}

	tmpl := `name: Release

on:{{range .ActionsOn}}{{if eq . "On version tags (v*)"}}
  push:
    tags:
      - 'v*'{{else if eq . "On all tags"}}
  push:
    tags:
      - '*'{{else if eq . "Manual trigger only"}}
  workflow_dispatch:{{else if eq . "On push to main"}}
  push:
    branches: [main]{{end}}{{end}}

permissions:
  contents: write{{if .DockerEnabled}}
  packages: write{{end}}{{if .Signing}}
  id-token: write{{end}}

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true
      {{if .DockerEnabled}}
      - name: Login to Docker Registry
        uses: docker/login-action@v3
        with:{{if contains .DockerRegistry "ghcr.io"}}
          registry: ghcr.io
          username: ${{"{{"}} github.actor {{"}}"}}
          password: ${{"{{"}} secrets.GITHUB_TOKEN {{"}}"}}{{else}}
          registry: {{.DockerRegistry}}
          username: ${{"{{"}} secrets.DOCKER_USERNAME {{"}}"}}
          password: ${{"{{"}} secrets.DOCKER_PASSWORD {{"}}"}}{{end}}
      {{end}}{{if .Signing}}
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3
      {{end}}{{if .SBOM}}
      - name: Install Syft
        uses: anchore/sbom-action/download-syft@v0
      {{end}}
      - name: Run GoReleaser
        uses: goreleaser/goreleaser-action@v6
        with:
          version: latest
          args: release --clean{{if .ProVersion}}
          distribution: goreleaser-pro{{end}}
        env:
          GITHUB_TOKEN: ${{"{{"}} secrets.GITHUB_TOKEN {{"}}"}}
          GITHUB_OWNER: ${{"{{"}} github.repository_owner {{"}}"}}
          GITHUB_REPO: ${{"{{"}} github.event.repository.name {{"}}"}}{{if .ProVersion}}
          GORELEASER_KEY: ${{"{{"}} secrets.GORELEASER_KEY {{"}}"}}{{end}}{{if .Homebrew}}
          HOMEBREW_TAP_GITHUB_TOKEN: ${{"{{"}} secrets.HOMEBREW_TAP_GITHUB_TOKEN {{"}}"}}{{end}}
`

	t, err := template.New("actions").Funcs(template.FuncMap{
		"contains": strings.Contains,
	}).Parse(tmpl)
	if err != nil {
		return TemplateError("github actions template parsing", err)
	}

	workflowFile := filepath.Join(".github", "workflows", "release.yml")
	file, err := SafeCreateFile(workflowFile)
	if err != nil {
		return err // Already wrapped by SafeCreateFile
	}
	defer func() {
		if closeErr := file.Close(); closeErr != nil {
			// Log close error but don't override main error
			log.Warn("Failed to close file", "file", workflowFile, "error", closeErr)
		}
	}()

	if err := t.Execute(file, config); err != nil {
		return TemplateError("github actions template execution", err)
	}
	return nil
}